<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>axis3_with_login.py Code Concepts Explanation</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f9f9f9;
            color: #333;
        }
        h1 {
            color: #A52A2A;
            text-align: center;
        }
        h2 {
            color: #8B0000;
            margin-top: 30px;
        }
        p {
            line-height: 1.6;
        }
        code {
            background-color: #eaeaea;
            padding: 2px 5px;
            border-radius: 4px;
            font-family: Consolas, monospace;
        }
        .section {
            background-color: white;
            padding: 20px;
            border-radius: 6px;
            box-shadow: 0 0 10px rgba(0,0,0,0.1);
            margin-bottom: 20px;
        }
        ul {
            margin-top: 10px;
        }
        ul li {
            margin-bottom: 8px;
        }
    </style>
</head>
<body>
    <h1>Explanation of Concepts in <code>axis3_with_login.py</code> Code</h1>

    <div class="section">
        <h2>1. Header and Its Purpose</h2>
        <p>
            The <code>header</code> in the context of this Python script refers primarily to the <code>import</code> statements and initial function definitions that set up the environment and functionalities.
            It includes importing libraries like <code>selenium</code> for browser automation, <code>requests</code> for HTTP checks, <code>threading</code> for parallel execution, <code>openpyxl</code> for Excel file handling, and extensive use of <code>explicit waits</code> to ensure element readiness.
        </p>
        <p>
            Headers serve to bring in external code and utilities needed throughout the script. They also provide a high-level overview of external dependencies and core modules the script requires to operate.
        </p>
        <p><strong>When to use:</strong> At the beginning of almost every Python script or module, import statements should be declared for any external libraries or modules your code depends on.</p>
        <p><strong>Why important:</strong> Without importing necessary libraries, the script cannot access essential functions or classes, leading to errors.</p>
    </div>

    <div class="section">
        <h2>2. Detailed Function Definitions and Their Role</h2>
        <p>The script defines several functions encapsulating distinct tasks with proper consideration of asynchronous and dynamic web behaviors:</p>
        <ul>
            <li><code>check_link(url)</code>: Uses <code>requests.get</code> with a timeout to validate external URLs, capturing HTTP response codes and exceptions.</li>
            <li><code>run_check(activity_url, check_id, report_data, dashboard_data)</code>: Automates browser interactions per activity URL using a headless Chrome browser instance. Key Points:
                <ul>
                    <li>Uses <code>explicit waits</code> extensively to wait for elements such as textareas, buttons, and input fields, avoiding flaky tests.</li>
                    <li>Extracts URLs from textarea text using regular expressions.</li>
                    <li>Opens target URLs in new tabs, waits for page load via title detection.</li>
                    <li>Takes screenshots to a predefined folder and tries multiple retries during element interactions to avoid stale element reference exceptions.</li>
                    <li>Handles errors gracefully by logging and including error details in report structures.</li>
                </ul>
            </li>
            <li><code>automate_login(driver, wait)</code>: Automates the login process with explicit wait for username and password fields and login button. It tries to catch timeout or failure errors and logs appropriately.</li>
            <li><code>main()</code>: Orchestrates initializing the browser, performs conditional login if redirected to login page, runs activity checks in parallel threads, and manages data collection.
                Key aspects include:
                <ul>
                    <li>Window maximization for better visibility.</li>
                    <li>Explicit waits for all critical interactions.</li>
                    <li>Threaded parallel execution with proper synchronization.</li>
                    <li>Excel report generation using <code>openpyxl</code> with error handling on file access.</li>
                    <li>Saving dashboard data to browser localStorage for use by the dashboard webpage.</li>
                </ul>
            </li>
        </ul>
        <p><strong>When to use:</strong> Functions modularize the script for clarity, reusability, error isolation, and to handle asynchronous behaviors effectively.</p>
    </div>

    <div class="section">
        <h2>3. Using Selenium Browser Automation with Explicit Waits</h2>
        <p>The script intensively uses Selenium WebDriver with <code>explicit waits</code> to reliably automate browser tasks:
        </p>
        <ul>
            <li>Explicit waits (<code>WebDriverWait</code>) wait for elements to be present, visible, or clickable before acting on them.</li>
            <li>Helps mitigate timing issues and dynamic loading delays.</li>
            <li>Retries are built into critical interaction points (e.g., clicking, sending keys) to handle <code>stale element reference</code> exceptions.</li>
            <li>Switching tabs and frames is done explicitly to control focus context.</li>
            <li>Headless mode is used for parallel threads to improve efficiency, while main execution is headful for better debugging.</li>
        </ul>
        <p><strong>When to use Selenium with explicit waits:</strong> For applications with dynamic JavaScript content, asynchronous loads, or when interacting with input fields and buttons that might not be immediately available.</p>
    </div>


    <div class="section">
        <h2>4. Parallel Execution with <code>threading</code></h2>
        <p>The script uses Python's <code>threading</code> module to run multiple activity checks simultaneously:</p>
        <ul>
            <li>Each activity URL is processed in its own thread with a separate headless Chrome instance.</li>
            <li>This approach speeds up the overall process since activities can be checked in parallel rather than sequentially.</li>
        </ul>
        <p><strong>When to use threading:</strong> Use threading to perform multiple tasks concurrently, especially when tasks are I/O bound (waiting on network or disk) like web requests or browser automation.</p>
    </div>

    <div class="section">
        <h2>5. Handling Errors and Retries</h2>
        <p>The code includes <code>try-except</code> blocks to handle exceptions during web interactions and network operations:</p>
        <ul>
            <li>In case of failures, errors are logged into the reports and dashboard data to ensure failures are traceable.</li>
            <li>Retries with small waits are used to mitigate <em>stale element reference</em> exceptions when interacting with web elements that may disappear/reload.</li>
        </ul>
        <p><strong>When to use:</strong> Always use error handling to make your automation more robust against transient failures or unexpected page states.</p>
    </div>

    <div class="section">
        <h2>6. Data Aggregation and Reporting</h2>
        <p>The script collects status results, reasons, and metadata into shared lists, then generates an Excel report using <code>openpyxl</code>. Additionally, dashboard data is serialized and stored in browser <code>localStorage</code> for in-browser reporting.</p>
        <p><strong>When to use:</strong> Collect and export data systematically for audit trails, reporting, or integration with other systems.</p>
    </div>

    <div class="section">
        <h2>7. When to Use This Script</h2>
        <p>This kind of script is useful when automating verification of multiple web activities that involve both network checks and user interactions, for example:</p>
        <ul>
            <li>End-to-end testing of complex workflows</li>
            <li>Automated monitoring of web services combined with UI validation</li>
            <li>Batch processing of tasks that require web form interactions and confirmations</li>
        </ul>
        <p>It is particularly suitable when manual checking is time-consuming and error-prone.</p>
    </div>

</body>
</html>
